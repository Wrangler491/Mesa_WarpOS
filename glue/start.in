/*
 *  This file is part of ixemul.library for the Amiga.
 *  Copyright (C) 1991, 1992  Markus M. Wild
 *  Portions Copyright (C) 1994 Rafael W. Luebbert
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Library General Public
 *  License as published by the Free Software Foundation; either
 *  version 2 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Library General Public
 *  License along with this library; if not, write to the Free
 *  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#define START
#include "../include/library_gl@TARGET@.h"
#include "../include/version_gl@TARGET@.h"

/* size of C_PRIVATE was generated by create_header.c */
/* include the generated header */
#include "../start/start_gl@TARGET@.h"


	.text

   | The first executable location.  This should return an error
   | in case someone tried to run you as a program (instead of
   | loading you as a library).
	.globl	Start		| we use this to force inclusion of start.s
Start:
   movel   #-1,d0
   rts

|-----------------------------------------------------------------------
| A romtag structure.  Both "exec" and "ramlib" look for
| this structure to discover magic constants about you
| (such as where to start running you from...).
|-----------------------------------------------------------------------

initDDescrip:
               |STRUCTURE RT,0
     .word    RTC_MATCHWORD           | UWORD RT_MATCHWORD
     .long    initDDescrip            | APTR  RT_MATCHTAG
     .long    EndCode                 | APTR  RT_ENDSKIP
     .byte    RTF_AUTOINIT            | UBYTE RT_FLAGS
     .byte    MesaGL@TARGET@_VERSION  | UBYTE RT_VERSION
     .byte    NT_LIBRARY              | UBYTE RT_TYPE
     .byte    MesaGL@TARGET@_PRIORITY | BYTE  RT_PRI
     .long    name@TARGET@     | APTR  RT_NAME
     .long    idString@TARGET@ | APTR  RT_IDSTRING
     .long    Init                    | APTR  RT_INIT

| this is just fool proof, and this library will never make it to ROM
| anyway, so resident tags are not that important ;-)
EndCode:


   | this is the name that the library will have
name@TARGET@:    .asciz MesaGL@TARGET@_NAME

   | this is an identifier tag to help in supporting the library
   | format is name version.revision (dd.mm.yy),<cr>,<lf>,<null>
   | without any leading zeros in dd.mm.yy
idString@TARGET@:
	.ascii MesaGL@TARGET@_IDSTRING
	.byte 13
	.byte 10
	.byte 0

   | force word alignment
   .even

   | The romtag specified that we were "RTF_AUTOINIT".  This means
   | that the RT_INIT structure member points to one of these
   | tables below.  If the AUTOINIT bit was not set then RT_INIT
   | would point to a routine to run.

Init:
   .long   MesaGL@TARGET@BASE_SIZEOF	| size of library base data space
   .long   funcTable		| pointer to function initializers
   .long   dataTable            | pointer to data initializers
   .long   _initRoutine	        | routine to run


funcTable:

   |------ standard system routines
   .long   _libOpen
   .long   _libClose
   .long   _libExpunge
   .long   Null

   |------ my libraries definitions

#define __reserved	Null

#define SYSTEM_CALL(func, vec) .long _##func
#include "../include/GL/gl@TARGET@_calls.def"
#undef SYSTEM_CALL

   |------ function table end marker
   .long   -1

   | The data table initializes static data structures.
   | The format is specified in exec/InitStruct routines
   | manual pages.  The INITBYTE/INITWORD/INITLONG routines
   | are in the file "exec/initializers.i".  The first argument
   | is the offset from the library base for this byte/word/long.
   | The second argument is the value to put in that cell.
   | The table is null terminated
   | NOTE - LN_TYPE below is a correction - old example had LH_TYPE

dataTable:
	INITBYTE (LN_TYPE, 		        NT_LIBRARY)
	INITLONG (LN_NAME, 		        name@TARGET@)
	INITBYTE (MesaGL@TARGET@BASE_FLAGS, 	0x6) | LIBF_CHANGED_SUMUSED
	INITWORD (MesaGL@TARGET@BASE_VERSION, 	MesaGL@TARGET@_VERSION)
	INITWORD (MesaGL@TARGET@BASE_REVISION, 	MesaGL@TARGET@_REVISION)
	INITLONG (MesaGL@TARGET@BASE_IDSTRING, 	idString@TARGET@)
	.long   0

   | This routine gets called after the library has been allocated.
   | The library pointer is in D0.  The segment list is in A0.
   | If it returns non-zero then the library will be linked into
   | the library list.

_initRoutine:
   |------ get the library pointer into a convenient A register
   movel   a5,sp@-
   movel   d0,a5

   |------ save a pointer to our loaded code
   movel   a0,a5@(MesaGL@TARGET@BASE_SEGLIST)

   |------ do the higher-level initialization in C
   |------ the MesaGL@TARGET@init function checks if the hardware is supported
   |------ (using 68000 instructions only) and if so will call MesaGL@TARGET@init()
   |------ for the main initialization.
|  pea	   a5@
|  jsr	   _MesaGL@TARGET@init
|  addqw   #4,sp

   movel   sp@+,a5
   rts

|----------------------------------------------------------------------
|
| here begins the system interface commands.  When the user calls
| OpenLibrary/CloseLibrary/RemoveLibrary, this eventually gets translated
| into a call to the following routines (Open/Close/Expunge).  Exec
| has already put our library pointer in A6 for us.  Exec has turned
| off task switching while in these routines (via Forbid/Permit), so
| we should not take too long in them.
|
|----------------------------------------------------------------------


   | Open returns the library pointer in d0 if the open
   | was successful.  If the open failed then null is returned.
   | It might fail if we allocated memory on each open, or
   | if only open application could have the library open
   | at a time...

_libOpen:      | ( libptr:a6, version:d0 )
   |------ mark us as having another opener
   addqw   #1,a6@(MesaGL@TARGET@BASE_OPENCNT)

   |------ prevent delayed expunges
   | !!!!!!
   | commo - example code uses private flags field (MesaGL@TARGET@BASE_MYFLAGS), WHY????
   | !!!!!!
   bclr    #LIBB_DELEXP,a6@(MesaGL@TARGET@BASE_FLAGS)

   |------ do other things in C
|  pea	   a6@
|  jsr	   _MesaGL@TARGET@open
|  addqw   #4,sp
|  beq     OpenFailed
   |--- MesaGL@TARGET@open() should return the library base, if all ok

   rts

OpenFailed:
   subqw  #1,a6@(MesaGL@TARGET@BASE_OPENCNT)
   rts

   | There are two different things that might be returned from
   | the Close routine.  If the library is no longer open and
   | there is a delayed expunge then Close should return the
   | segment list (as given to Init).  Otherwise close should
   | return NULL.

_libClose:      | ( libptr:a6 )
   |------ do any cleanups needed in C
|  pea	   a6@
|  jsr	   _MesaGL@TARGET@close
|  addqw   #4,sp

   |------ mark us as having one fewer openers
   subqw   #1,a6@(MesaGL@TARGET@BASE_OPENCNT)

   |------ see if there is anyone left with us open
   bne     Null

   |------ see if we have a delayed expunge pending
   btst    #LIBB_DELEXP,a6@(MesaGL@TARGET@BASE_FLAGS)	| SEE ABOVE!
   bne     _libExpunge

   | reserved entry

Null:
   moveq   #0,d0
   rts

   | There are two different things that might be returned from
   | the Expunge routine.  If the library is no longer open
   | then Expunge should return the segment list (as given to
   | Init).  Otherwise Expunge should set the delayed expunge
   | flag and return NULL.
   |
   | One other important note: because Expunge is called from
   | the memory allocator, it may NEVER Wait() or otherwise
   | take long time to complete.

_libExpunge:   | ( libptr: a6 )
   moveml  a2/a5/a6,sp@-
   movel   a6,a5

   |------ assume we cant expunge
   subal   a2,a2
   bset    #LIBB_DELEXP,a5@(MesaGL@TARGET@BASE_FLAGS)	| SEE ABOVE !!

   |------ see if anyone has us open
   tstw    a5@(MesaGL@TARGET@BASE_OPENCNT)
   bne     L21

   |------ go ahead and get rid of us.  Store our seglist in a2
   movel   a5@(MesaGL@TARGET@BASE_SEGLIST),a2
   movel   4:w,a6

   |------ unlink from library list
   movel   a5,a1
   jsr	   a6@(_LVORemove)

   |
   | device specific closings here...
   |
|  pea	   a5@
|  jsr	   _MesaGL@TARGET@expunge
|  addqw   #4,sp

   |------ free our memory
   movel   a5,a1
   moveq   #0,d0
   movew   a5@(MesaGL@TARGET@BASE_NEGSIZE),d0
   subl    d0,a1
   addw    a5@(MesaGL@TARGET@BASE_POSSIZE),d0
   jsr	   a6@(_LVOFreeMem)

L21:       |------ set up our return value
   movel   a2,d0

   moveml  sp@+,a2/a5/a6
   rts
